/* Generated by Yosys 0.7 (git sha1 61f6811, i686-w64-mingw32.static-gcc 4.9.3 -Os) */

(* src = "Sumador.v:1" *)
module Sumador(clk, reset, dataA, dataB, sum30_dd);
  (* src = "Sumador.v:18" *)
  reg _00_;
  (* src = "Sumador.v:18" *)
  reg _01_;
  (* src = "Sumador.v:18" *)
  reg [3:0] _02_;
  (* src = "Sumador.v:18" *)
  reg [3:0] _03_;
  (* src = "Sumador.v:18" *)
  reg [3:0] _04_;
  (* src = "Sumador.v:18" *)
  reg [3:0] _05_;
  (* src = "Sumador.v:18" *)
  reg [1:0] _06_;
  (* src = "Sumador.v:18" *)
  reg [1:0] _07_;
  (* src = "Sumador.v:32" *)
  wire [1:0] _08_;
  (* src = "Sumador.v:36" *)
  wire [1:0] _09_;
  (* src = "Sumador.v:36" *)
  wire [1:0] _10_;
  (* src = "Sumador.v:33" *)
  wire _11_;
  (* src = "Sumador.v:33" *)
  wire _12_;
  (* src = "Sumador.v:33" *)
  wire _13_;
  (* src = "Sumador.v:19" *)
  wire _14_;
  (* src = "Sumador.v:14" *)
  reg acarreo;
  (* src = "Sumador.v:15" *)
  reg acarreo_d;
  (* src = "Sumador.v:3" *)
  input clk;
  (* src = "Sumador.v:5" *)
  input [3:0] dataA;
  (* src = "Sumador.v:12" *)
  reg [3:0] dataA_d;
  (* src = "Sumador.v:6" *)
  input [3:0] dataB;
  (* src = "Sumador.v:13" *)
  reg [3:0] dataB_d;
  (* src = "Sumador.v:4" *)
  input reset;
  (* src = "Sumador.v:16" *)
  reg [3:0] sum30_d;
  (* src = "Sumador.v:7" *)
  output [3:0] sum30_dd;
  reg [3:0] sum30_dd;
  (* src = "Sumador.v:10" *)
  reg [1:0] sum_temp;
  (* src = "Sumador.v:11" *)
  reg [1:0] sum_temp_d;
  assign _08_ = dataA[1:0] + (* src = "Sumador.v:32" *) dataB[1:0];
  assign _09_ = dataA_d[3:2] + (* src = "Sumador.v:36" *) dataB_d[3:2];
  assign _10_ = _09_ + (* src = "Sumador.v:36" *) acarreo_d;
  assign _11_ = dataA[0] & (* src = "Sumador.v:33" *) dataA[1];
  assign _12_ = _11_ & (* src = "Sumador.v:33" *) dataB[1];
  assign _13_ = _12_ & (* src = "Sumador.v:33" *) dataB[0];
  assign _14_ = ! (* src = "Sumador.v:19" *) reset;
  always @* begin
    _05_ = sum30_dd;
    _06_ = sum_temp;
    _07_ = sum_temp_d;
    _02_ = dataA_d;
    _03_ = dataB_d;
    _00_ = acarreo;
    _01_ = acarreo_d;
    _04_ = sum30_d;
    casez (_14_)
      1'b1:
        begin
          _05_ = 4'b0000;
          _06_ = 2'b00;
          _07_ = 2'b00;
          _02_ = 4'b0000;
          _03_ = 4'b0000;
          _00_ = 1'b0;
          _01_ = 1'b0;
          _04_ = 4'b0000;
        end
      default:
        begin
          _02_ = dataA;
          _03_ = dataB;
          _06_ = _08_;
          _00_ = _13_;
          _07_ = sum_temp;
          _01_ = acarreo;
          _04_[3:2] = _10_;
          _04_[1:0] = sum_temp_d;
          _05_ = sum30_d;
        end
    endcase
  end
  always @(posedge clk) begin
      sum30_dd <= _05_;
      sum_temp <= _06_;
      sum_temp_d <= _07_;
      dataA_d <= _02_;
      dataB_d <= _03_;
      acarreo <= _00_;
      acarreo_d <= _01_;
      sum30_d <= _04_;
  end
endmodule

(* top =  1  *)
(* src = "Sumador_pipe.v:3" *)
module Sumador_pipe(clk, reset, idx, dataA, dataB, idx_dd, sum30_dd);
  (* src = "Sumador_pipe.v:15" *)
  reg [3:0] _0_;
  (* src = "Sumador_pipe.v:15" *)
  reg [3:0] _1_;
  (* src = "Sumador_pipe.v:20" *)
  wire [31:0] _2_;
  (* src = "Sumador_pipe.v:21" *)
  wire [31:0] _3_;
  (* src = "Sumador_pipe.v:16" *)
  wire _4_;
  (* src = "Sumador_pipe.v:4" *)
  input clk;
  (* src = "Sumador_pipe.v:7" *)
  input [3:0] dataA;
  (* src = "Sumador_pipe.v:8" *)
  input [3:0] dataB;
  (* src = "Sumador_pipe.v:6" *)
  input [3:0] idx;
  (* src = "Sumador_pipe.v:13" *)
  reg [3:0] idx_d;
  (* src = "Sumador_pipe.v:9" *)
  output [3:0] idx_dd;
  reg [3:0] idx_dd;
  (* src = "Sumador_pipe.v:5" *)
  input reset;
  (* src = "Sumador_pipe.v:10" *)
  output [3:0] sum30_dd;
  assign _2_ = idx + (* src = "Sumador_pipe.v:20" *) 32'd1;
  assign _3_ = idx_d + (* src = "Sumador_pipe.v:21" *) 32'd1;
  assign _4_ = ! (* src = "Sumador_pipe.v:16" *) reset;
  (* src = "Sumador_pipe.v:25" *)
  Sumador s1 (
    .clk(clk),
    .dataA(dataA),
    .dataB(dataB),
    .reset(reset),
    .sum30_dd(sum30_dd)
  );
  always @* begin
    _1_ = idx_dd;
    _0_ = idx_d;
    casez (_4_)
      1'b1:
        begin
          _0_ = 4'b0000;
          _1_ = 4'b0000;
        end
      default:
        begin
          _0_ = _2_[3:0];
          _1_ = _3_[3:0];
        end
    endcase
  end
  always @(posedge clk) begin
      idx_dd <= _1_;
      idx_d <= _0_;
  end
endmodule
